
/*
 * Triple Play Pay API
 *
 * Payment API
 *
 * API version: 1.0.1-oas3
 * Contact: support@tripleplaypay.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ApiApiService service
/*
ApiApiService Setup new Credit Card Terminal.
Setup new Credit Card Terminal.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param activationCode Activation Code on Terminal Screen
 * @param terminalId Custom Name of Terminal
 * @param optional nil or *ApiApiActivateOpts - Optional Parameters:
     * @param "Meta" (optional.Interface of interface{}) -  Optional user defined object to be returned with future response
@return []Response
*/

type ApiApiActivateOpts struct {
    Meta optional.Interface
}

func (a *ApiApiService) Activate(ctx context.Context, activationCode string, terminalId string, localVarOptionals *ApiApiActivateOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/activate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("activationCode", parameterToString(activationCode, ""))
	localVarQueryParams.Add("terminalId", parameterToString(terminalId, ""))
	if localVarOptionals != nil && localVarOptionals.Meta.IsSet() {
		localVarQueryParams.Add("meta", parameterToString(localVarOptionals.Meta.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService Used to verify funds when the total amount of the purchase is unknown.
Used to verify funds when the total amount of the purchase is unknown.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param amount The total transaction amount. This is the amount of funds to move on the card
 * @param cc Credit Card Number with or without dashes
 * @param mm 2 digit Month
 * @param yy 2 digit Year
 * @param cvv Card Verification Value found on the card (CVV2, CVC2, CID)
 * @param optional nil or *ApiApiAuthorizeOpts - Optional Parameters:
     * @param "Zipcode" (optional.String) -  Zip code. *optional synonym: zip
     * @param "Ticket" (optional.String) -  Ticket Number used by POS
     * @param "Meta" (optional.Interface of interface{}) -  Optional user defined object to be returned with future response
@return []Response
*/

type ApiApiAuthorizeOpts struct {
    Zipcode optional.String
    Ticket optional.String
    Meta optional.Interface
}

func (a *ApiApiService) Authorize(ctx context.Context, amount string, cc string, mm string, yy string, cvv string, localVarOptionals *ApiApiAuthorizeOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/authorize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("amount", parameterToString(amount, ""))
	localVarQueryParams.Add("cc", parameterToString(cc, ""))
	localVarQueryParams.Add("mm", parameterToString(mm, ""))
	localVarQueryParams.Add("yy", parameterToString(yy, ""))
	localVarQueryParams.Add("cvv", parameterToString(cvv, ""))
	if localVarOptionals != nil && localVarOptionals.Zipcode.IsSet() {
		localVarQueryParams.Add("zipcode", parameterToString(localVarOptionals.Zipcode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ticket.IsSet() {
		localVarQueryParams.Add("ticket", parameterToString(localVarOptionals.Ticket.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Meta.IsSet() {
		localVarQueryParams.Add("meta", parameterToString(localVarOptionals.Meta.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService Process payment or settle a previous charge. *card **bank
Process payment or settle a previous charge. *card **bank
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param amount The total transaction amount. This is the amount of funds to move on the card
 * @param cc Credit Card Number with or without dashes
 * @param mm 2 digit month
 * @param yy 2 digit year
 * @param cvv Card Verification Value found on the card (CVV2, CVC2, CID)
 * @param accountNumber Bank Account Number
 * @param routingNumber Bank Routing Number
 * @param type_ Options: checking, savings *default checking
 * @param optional nil or *ApiApiChargeOpts - Optional Parameters:
     * @param "Id" (optional.String) -  Transaction ID used to settle an authorized payment method (cc or bank info then not required) *optional synonym: transactionId
     * @param "Zipcode" (optional.String) -  Zip code. *optional synonym: zip
     * @param "Ticket" (optional.String) -  Ticket Number used by POS
     * @param "Meta" (optional.Interface of interface{}) -  Optional user defined object to be returned with future response
@return []Response
*/

type ApiApiChargeOpts struct {
    Id optional.String
    Zipcode optional.String
    Ticket optional.String
    Meta optional.Interface
}

func (a *ApiApiService) Charge(ctx context.Context, amount string, cc string, mm string, yy string, cvv string, accountNumber string, routingNumber string, type_ string, localVarOptionals *ApiApiChargeOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/charge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("amount", parameterToString(amount, ""))
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	localVarQueryParams.Add("cc", parameterToString(cc, ""))
	localVarQueryParams.Add("mm", parameterToString(mm, ""))
	localVarQueryParams.Add("yy", parameterToString(yy, ""))
	localVarQueryParams.Add("cvv", parameterToString(cvv, ""))
	if localVarOptionals != nil && localVarOptionals.Zipcode.IsSet() {
		localVarQueryParams.Add("zipcode", parameterToString(localVarOptionals.Zipcode.Value(), ""))
	}
	localVarQueryParams.Add("accountNumber", parameterToString(accountNumber, ""))
	localVarQueryParams.Add("routingNumber", parameterToString(routingNumber, ""))
	localVarQueryParams.Add("type", parameterToString(type_, ""))
	if localVarOptionals != nil && localVarOptionals.Ticket.IsSet() {
		localVarQueryParams.Add("ticket", parameterToString(localVarOptionals.Ticket.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Meta.IsSet() {
		localVarQueryParams.Add("meta", parameterToString(localVarOptionals.Meta.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService A Credit transaction is used to refund a cardholder for a previous transaction.
A Credit transaction is used to refund a cardholder for a previous transaction.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param amount The total transaction amount. This is the amount of funds to move on the card
 * @param cc Credit Card Number with or without dashes
 * @param mm 2 digit month
 * @param yy 2 digit year
 * @param cvv Card Verification Value found on the card (CVV2, CVC2, CID)
 * @param optional nil or *ApiApiCreditOpts - Optional Parameters:
     * @param "Zipcode" (optional.String) -  Zip code. *optional synonym: zip
     * @param "Ticket" (optional.String) -  Ticket Number used by POS
     * @param "Meta" (optional.Interface of interface{}) -  Optional user defined object to be returned with future response
@return []Response
*/

type ApiApiCreditOpts struct {
    Zipcode optional.String
    Ticket optional.String
    Meta optional.Interface
}

func (a *ApiApiService) Credit(ctx context.Context, amount string, cc string, mm string, yy string, cvv string, localVarOptionals *ApiApiCreditOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/credit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("amount", parameterToString(amount, ""))
	localVarQueryParams.Add("cc", parameterToString(cc, ""))
	localVarQueryParams.Add("mm", parameterToString(mm, ""))
	localVarQueryParams.Add("yy", parameterToString(yy, ""))
	localVarQueryParams.Add("cvv", parameterToString(cvv, ""))
	if localVarOptionals != nil && localVarOptionals.Zipcode.IsSet() {
		localVarQueryParams.Add("zipcode", parameterToString(localVarOptionals.Zipcode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ticket.IsSet() {
		localVarQueryParams.Add("ticket", parameterToString(localVarOptionals.Ticket.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Meta.IsSet() {
		localVarQueryParams.Add("meta", parameterToString(localVarOptionals.Meta.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService Enroll a new merchant or retrieve status of pending merchant.
Enroll a new merchant or retrieve status of pending merchant.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param dbaName Doing Business As name. &lt;code&gt;*&lt;/code&gt; Only field necessary for GET.
 * @param email
 * @param website
 * @param fedTxId
 * @param legalName Legal Business Name
 * @param startDate Business Start Date
 * @param accountHolderName
 * @param accountType
 * @param accountNumber Bank Account to deposit transactions. 
 * @param routingNumber Bank Routing Number to deposit transactions.
 * @param ownershipType [\&quot;Sole Proprietor\&quot;, \&quot;C-Corp Private\&quot;, \&quot;C-Corp Public\&quot;, \&quot;S-Corp Private\&quot;, \&quot;S-Corp Public\&quot;, \&quot;LLC Private\&quot;, \&quot;LLC Public\&quot;, \&quot;Not For Profit\&quot;, \&quot;Partnership Private\&quot;, \&quot;Partnership\&quot;, \&quot;Government Agency\&quot;]
 * @param businessDescription
 * @param businessPhoneNumber
 * @param businessAddress1
 * @param businessAddress2
 * @param businessCity
 * @param businessStateProvince
 * @param businessPostalCode
 * @param principleFirstName Primary Owners First Name. Adding a number to the parameter allows for adding multiple principle owners. Example: &lt;strong&gt;2principle_first_name&lt;/strong&gt;
 * @param principleLastName Primary Owners Last Name.
 * @param principleSsn Primary Owners Social Security Number
 * @param principleDateOfBirth
 * @param principleAddressLine1
 * @param principleAddressLine2
 * @param principleCity
 * @param principleStateProvince
 * @param principlePostalCode
 * @param principleTitle
 * @param principleOwnershipPercentage
 * @param principlePhoneNumber
 * @param optional nil or *ApiApiEnrollOpts - Optional Parameters:
     * @param "StockSymbol" (optional.String) - 
@return []Response
*/

type ApiApiEnrollOpts struct {
    StockSymbol optional.String
}

func (a *ApiApiService) Enroll(ctx context.Context, dbaName string, email string, website string, fedTxId string, legalName string, startDate string, accountHolderName string, accountType string, accountNumber string, routingNumber string, ownershipType string, businessDescription string, businessPhoneNumber string, businessAddress1 string, businessAddress2 string, businessCity string, businessStateProvince string, businessPostalCode string, principleFirstName string, principleLastName string, principleSsn string, principleDateOfBirth string, principleAddressLine1 string, principleAddressLine2 string, principleCity string, principleStateProvince string, principlePostalCode string, principleTitle string, principleOwnershipPercentage string, principlePhoneNumber string, localVarOptionals *ApiApiEnrollOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/enroll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("dba_name", parameterToString(dbaName, ""))
	localVarQueryParams.Add("email", parameterToString(email, ""))
	localVarQueryParams.Add("website", parameterToString(website, ""))
	localVarQueryParams.Add("fed_tx_id", parameterToString(fedTxId, ""))
	localVarQueryParams.Add("legal_name", parameterToString(legalName, ""))
	localVarQueryParams.Add("start_date", parameterToString(startDate, ""))
	localVarQueryParams.Add("account_holder_name", parameterToString(accountHolderName, ""))
	localVarQueryParams.Add("account_type", parameterToString(accountType, ""))
	localVarQueryParams.Add("account_number", parameterToString(accountNumber, ""))
	localVarQueryParams.Add("routing_number", parameterToString(routingNumber, ""))
	if localVarOptionals != nil && localVarOptionals.StockSymbol.IsSet() {
		localVarQueryParams.Add("stock_symbol", parameterToString(localVarOptionals.StockSymbol.Value(), ""))
	}
	localVarQueryParams.Add("ownership_type", parameterToString(ownershipType, ""))
	localVarQueryParams.Add("business_description", parameterToString(businessDescription, ""))
	localVarQueryParams.Add("business_phone_number", parameterToString(businessPhoneNumber, ""))
	localVarQueryParams.Add("business_address_1", parameterToString(businessAddress1, ""))
	localVarQueryParams.Add("business_address_2", parameterToString(businessAddress2, ""))
	localVarQueryParams.Add("business_city", parameterToString(businessCity, ""))
	localVarQueryParams.Add("business_state_province", parameterToString(businessStateProvince, ""))
	localVarQueryParams.Add("business_postal_code", parameterToString(businessPostalCode, ""))
	localVarQueryParams.Add("principle_first_name", parameterToString(principleFirstName, ""))
	localVarQueryParams.Add("principle_last_name", parameterToString(principleLastName, ""))
	localVarQueryParams.Add("principle_ssn", parameterToString(principleSsn, ""))
	localVarQueryParams.Add("principle_date_of_birth", parameterToString(principleDateOfBirth, ""))
	localVarQueryParams.Add("principle_address_line_1", parameterToString(principleAddressLine1, ""))
	localVarQueryParams.Add("principle_address_line_2", parameterToString(principleAddressLine2, ""))
	localVarQueryParams.Add("principle_city", parameterToString(principleCity, ""))
	localVarQueryParams.Add("principle_state_province", parameterToString(principleStateProvince, ""))
	localVarQueryParams.Add("principle_postal_code", parameterToString(principlePostalCode, ""))
	localVarQueryParams.Add("principle_title", parameterToString(principleTitle, ""))
	localVarQueryParams.Add("principle_ownership_percentage", parameterToString(principleOwnershipPercentage, ""))
	localVarQueryParams.Add("principle_phone_number", parameterToString(principlePhoneNumber, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService Get transaction detail history
Get transaction detail history
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ApiApiReportOpts - Optional Parameters:
     * @param "Start" (optional.String) -  Start of date range YYYY-MM-DD **defaults to that day
     * @param "End" (optional.String) -  End of date range YYYY-MM-DD
     * @param "Dates" (optional.String) -  Optional list of range, example: [\&quot;YYYY-MM-DD\&quot;,\&quot;YYYY-MM-DD\&quot;]
@return []Response
*/

type ApiApiReportOpts struct {
    Start optional.String
    End optional.String
    Dates optional.String
}

func (a *ApiApiService) Report(ctx context.Context, localVarOptionals *ApiApiReportOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Start.IsSet() {
		localVarQueryParams.Add("start", parameterToString(localVarOptionals.Start.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.End.IsSet() {
		localVarQueryParams.Add("end", parameterToString(localVarOptionals.End.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Dates.IsSet() {
		localVarQueryParams.Add("dates", parameterToString(localVarOptionals.Dates.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService Alternative to sending a transactionId to charge, this method will settle an outstanding Authorization.
Alternative to sending a transactionId to charge, this method will settle an outstanding Authorization.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Transaction ID of charged event. *optional synonym: transactionId
 * @param optional nil or *ApiApiSettleOpts - Optional Parameters:
     * @param "Ticket" (optional.String) -  Ticket Number used by POS
     * @param "Meta" (optional.Interface of interface{}) -  Optional user defined object to be returned with future response
@return []Response
*/

type ApiApiSettleOpts struct {
    Ticket optional.String
    Meta optional.Interface
}

func (a *ApiApiService) Settle(ctx context.Context, id string, localVarOptionals *ApiApiSettleOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/settle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("id", parameterToString(id, ""))
	if localVarOptionals != nil && localVarOptionals.Ticket.IsSet() {
		localVarQueryParams.Add("ticket", parameterToString(localVarOptionals.Ticket.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Meta.IsSet() {
		localVarQueryParams.Add("meta", parameterToString(localVarOptionals.Meta.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService Create a token for later use.
Create a token for later use.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cc Credit Card Number with or without dashes
 * @param mm 2 digit Month
 * @param yy 2 digit Year
 * @param cvv Card Verification Value found on the card (CVV2, CVC2, CID)
@return []Response
*/
func (a *ApiApiService) Tokenize(ctx context.Context, cc string, mm string, yy string, cvv string) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tokenize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("cc", parameterToString(cc, ""))
	localVarQueryParams.Add("mm", parameterToString(mm, ""))
	localVarQueryParams.Add("yy", parameterToString(yy, ""))
	localVarQueryParams.Add("cvv", parameterToString(cvv, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService A Void transaction can be used to back out a previous Sale transaction.
A Void transaction can be used to back out a previous Sale transaction.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Transaction ID of charged event. *optional synonym: transactionId
 * @param optional nil or *ApiApiVoidOpts - Optional Parameters:
     * @param "Ticket" (optional.String) -  Ticket Number used by POS
     * @param "Meta" (optional.Interface of interface{}) -  Optional user defined object to be returned with future response
@return []Response
*/

type ApiApiVoidOpts struct {
    Ticket optional.String
    Meta optional.Interface
}

func (a *ApiApiService) Void(ctx context.Context, id string, localVarOptionals *ApiApiVoidOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/void"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("id", parameterToString(id, ""))
	if localVarOptionals != nil && localVarOptionals.Ticket.IsSet() {
		localVarQueryParams.Add("ticket", parameterToString(localVarOptionals.Ticket.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Meta.IsSet() {
		localVarQueryParams.Add("meta", parameterToString(localVarOptionals.Meta.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
