
/*
 * Triple Play Pay API
 *
 * Payment API
 *
 * API version: 1.0.0
 * Contact: support@tripleplaypay.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ApiApiService service
/*
ApiApiService Used to verify funds when the total amount of the purchase is unknown.
Used to verify funds when the total amount of the purchase is unknown.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param amount The total transaction amount. This is the amount of funds to move on the card
 * @param cc Credit Card Number with or without dashes
 * @param mm 2 digit Month
 * @param yy 2 digit Year
 * @param cvv Card Verification Value found on the card (CVV2, CVC2, CID)
 * @param optional nil or *ApiApiAuthorizeOpts - Optional Parameters:
     * @param "Ticket" (optional.String) -  Ticket Number used by POS
     * @param "Meta" (optional.Interface of interface{}) -  Optional user defined object to be returned with future response
@return []Response
*/

type ApiApiAuthorizeOpts struct {
    Ticket optional.String
    Meta optional.Interface
}

func (a *ApiApiService) Authorize(ctx context.Context, amount string, cc string, mm string, yy string, cvv string, localVarOptionals *ApiApiAuthorizeOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/authorize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("amount", parameterToString(amount, ""))
	localVarQueryParams.Add("cc", parameterToString(cc, ""))
	localVarQueryParams.Add("mm", parameterToString(mm, ""))
	localVarQueryParams.Add("yy", parameterToString(yy, ""))
	localVarQueryParams.Add("cvv", parameterToString(cvv, ""))
	if localVarOptionals != nil && localVarOptionals.Ticket.IsSet() {
		localVarQueryParams.Add("ticket", parameterToString(localVarOptionals.Ticket.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Meta.IsSet() {
		localVarQueryParams.Add("meta", parameterToString(localVarOptionals.Meta.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService Charge a credit card or settle a previous charge.
Charge a credit card or settle a previous charge.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param amount The total transaction amount. This is the amount of funds to move on the card
 * @param transactionId Transaction ID used to settle an authorized card (cc info then not required)
 * @param cc Credit Card Number with or without dashes
 * @param mm 2 digit month
 * @param yy 2 digit year
 * @param cvv Card Verification Value found on the card (CVV2, CVC2, CID)
 * @param optional nil or *ApiApiChargeOpts - Optional Parameters:
     * @param "Ticket" (optional.String) -  Ticket Number used by POS
     * @param "Meta" (optional.Interface of interface{}) -  Optional user defined object to be returned with future response
@return []Response
*/

type ApiApiChargeOpts struct {
    Ticket optional.String
    Meta optional.Interface
}

func (a *ApiApiService) Charge(ctx context.Context, amount string, transactionId string, cc string, mm string, yy string, cvv string, localVarOptionals *ApiApiChargeOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/charge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("amount", parameterToString(amount, ""))
	localVarQueryParams.Add("transactionId", parameterToString(transactionId, ""))
	localVarQueryParams.Add("cc", parameterToString(cc, ""))
	localVarQueryParams.Add("mm", parameterToString(mm, ""))
	localVarQueryParams.Add("yy", parameterToString(yy, ""))
	localVarQueryParams.Add("cvv", parameterToString(cvv, ""))
	if localVarOptionals != nil && localVarOptionals.Ticket.IsSet() {
		localVarQueryParams.Add("ticket", parameterToString(localVarOptionals.Ticket.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Meta.IsSet() {
		localVarQueryParams.Add("meta", parameterToString(localVarOptionals.Meta.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService A Credit transaction is used to refund a cardholder for a previous transaction.
A Credit transaction is used to refund a cardholder for a previous transaction.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param amount The total transaction amount. This is the amount of funds to move on the card
 * @param cc Credit Card Number with or without dashes
 * @param mm 2 digit month
 * @param yy 2 digit year
 * @param cvv Card Verification Value found on the card (CVV2, CVC2, CID)
 * @param optional nil or *ApiApiCreditOpts - Optional Parameters:
     * @param "Ticket" (optional.String) -  Ticket Number used by POS
     * @param "Meta" (optional.Interface of interface{}) -  Optional user defined object to be returned with future response
@return []Response
*/

type ApiApiCreditOpts struct {
    Ticket optional.String
    Meta optional.Interface
}

func (a *ApiApiService) Credit(ctx context.Context, amount string, cc string, mm string, yy string, cvv string, localVarOptionals *ApiApiCreditOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/credit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("amount", parameterToString(amount, ""))
	localVarQueryParams.Add("cc", parameterToString(cc, ""))
	localVarQueryParams.Add("mm", parameterToString(mm, ""))
	localVarQueryParams.Add("yy", parameterToString(yy, ""))
	localVarQueryParams.Add("cvv", parameterToString(cvv, ""))
	if localVarOptionals != nil && localVarOptionals.Ticket.IsSet() {
		localVarQueryParams.Add("ticket", parameterToString(localVarOptionals.Ticket.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Meta.IsSet() {
		localVarQueryParams.Add("meta", parameterToString(localVarOptionals.Meta.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService Enroll a new merchant or retrieve status of pending merchant.
Enroll a new merchant or retrieve status of pending merchant.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param dbaName Doing Business As name. &lt;code&gt;*&lt;/code&gt; Only field necessary for GET.
 * @param email
 * @param website
 * @param fedTxId
 * @param legalName Legal Business Name
 * @param startDate Business Start Date
 * @param accountHolderName
 * @param accountType
 * @param accountNumber Bank Account to deposit transactions. 
 * @param routingNumber Bank Routing Number to deposit transactions.
 * @param ownershipType Select an ownership type:
 * @param businessDescription
 * @param businessPhoneNumber
 * @param businessAddress1
 * @param businessAddress2
 * @param businessCity
 * @param businessStateProvince
 * @param businessPostalCode
 * @param principleFirstName Primary Owners First Name. Adding a number to the parameter allows for adding multiple principle owners. Example: &lt;strong&gt;2principle_first_name&lt;/strong&gt;
 * @param principleLastName Primary Owners Last Name.
 * @param principleSsn Primary Owners Social Security Number
 * @param principleDateOfBirth
 * @param principleAddressLine1
 * @param principleAddressLine2
 * @param principleCity
 * @param principleStateProvince
 * @param principlePostalCode
 * @param principleTitle
 * @param principleOwnershipPercentage
 * @param principlePhoneNumber
 * @param optional nil or *ApiApiEnrollOpts - Optional Parameters:
     * @param "StockSymbol" (optional.String) - 
@return []Response
*/

type ApiApiEnrollOpts struct {
    StockSymbol optional.String
}

func (a *ApiApiService) Enroll(ctx context.Context, dbaName string, email string, website string, fedTxId string, legalName string, startDate string, accountHolderName string, accountType string, accountNumber string, routingNumber string, ownershipType []string, businessDescription string, businessPhoneNumber string, businessAddress1 string, businessAddress2 string, businessCity string, businessStateProvince string, businessPostalCode string, principleFirstName string, principleLastName string, principleSsn string, principleDateOfBirth string, principleAddressLine1 string, principleAddressLine2 string, principleCity string, principleStateProvince string, principlePostalCode string, principleTitle string, principleOwnershipPercentage string, principlePhoneNumber string, localVarOptionals *ApiApiEnrollOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/enroll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("dba_name", parameterToString(dbaName, ""))
	localVarQueryParams.Add("email", parameterToString(email, ""))
	localVarQueryParams.Add("website", parameterToString(website, ""))
	localVarQueryParams.Add("fed_tx_id", parameterToString(fedTxId, ""))
	localVarQueryParams.Add("legal_name", parameterToString(legalName, ""))
	localVarQueryParams.Add("start_date", parameterToString(startDate, ""))
	localVarQueryParams.Add("account_holder_name", parameterToString(accountHolderName, ""))
	localVarQueryParams.Add("account_type", parameterToString(accountType, ""))
	localVarQueryParams.Add("account_number", parameterToString(accountNumber, ""))
	localVarQueryParams.Add("routing_number", parameterToString(routingNumber, ""))
	if localVarOptionals != nil && localVarOptionals.StockSymbol.IsSet() {
		localVarQueryParams.Add("stock_symbol", parameterToString(localVarOptionals.StockSymbol.Value(), ""))
	}
	localVarQueryParams.Add("ownership_type", parameterToString(ownershipType, "multi"))
	localVarQueryParams.Add("business_description", parameterToString(businessDescription, ""))
	localVarQueryParams.Add("business_phone_number", parameterToString(businessPhoneNumber, ""))
	localVarQueryParams.Add("business_address_1", parameterToString(businessAddress1, ""))
	localVarQueryParams.Add("business_address_2", parameterToString(businessAddress2, ""))
	localVarQueryParams.Add("business_city", parameterToString(businessCity, ""))
	localVarQueryParams.Add("business_state_province", parameterToString(businessStateProvince, ""))
	localVarQueryParams.Add("business_postal_code", parameterToString(businessPostalCode, ""))
	localVarQueryParams.Add("principle_first_name", parameterToString(principleFirstName, ""))
	localVarQueryParams.Add("principle_last_name", parameterToString(principleLastName, ""))
	localVarQueryParams.Add("principle_ssn", parameterToString(principleSsn, ""))
	localVarQueryParams.Add("principle_date_of_birth", parameterToString(principleDateOfBirth, ""))
	localVarQueryParams.Add("principle_address_line_1", parameterToString(principleAddressLine1, ""))
	localVarQueryParams.Add("principle_address_line_2", parameterToString(principleAddressLine2, ""))
	localVarQueryParams.Add("principle_city", parameterToString(principleCity, ""))
	localVarQueryParams.Add("principle_state_province", parameterToString(principleStateProvince, ""))
	localVarQueryParams.Add("principle_postal_code", parameterToString(principlePostalCode, ""))
	localVarQueryParams.Add("principle_title", parameterToString(principleTitle, ""))
	localVarQueryParams.Add("principle_ownership_percentage", parameterToString(principleOwnershipPercentage, ""))
	localVarQueryParams.Add("principle_phone_number", parameterToString(principlePhoneNumber, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService Alternative to sending a transactionId to charge, this method will settle an outstanding Authorization.
Alternative to sending a transactionId to charge, this method will settle an outstanding Authorization.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param transactionId Transaction ID of charged event.
 * @param optional nil or *ApiApiSettleOpts - Optional Parameters:
     * @param "Ticket" (optional.String) -  Ticket Number used by POS
     * @param "Meta" (optional.Interface of interface{}) -  Optional user defined object to be returned with future response
@return []Response
*/

type ApiApiSettleOpts struct {
    Ticket optional.String
    Meta optional.Interface
}

func (a *ApiApiService) Settle(ctx context.Context, transactionId string, localVarOptionals *ApiApiSettleOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/settle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("transactionId", parameterToString(transactionId, ""))
	if localVarOptionals != nil && localVarOptionals.Ticket.IsSet() {
		localVarQueryParams.Add("ticket", parameterToString(localVarOptionals.Ticket.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Meta.IsSet() {
		localVarQueryParams.Add("meta", parameterToString(localVarOptionals.Meta.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService Create a token for later use.
Create a token for later use.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cc Credit Card Number with or without dashes
 * @param mm 2 digit Month
 * @param yy 2 digit Year
 * @param cvv Card Verification Value found on the card (CVV2, CVC2, CID)
@return []Response
*/
func (a *ApiApiService) Tokenize(ctx context.Context, cc string, mm string, yy string, cvv string) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/tokenize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("cc", parameterToString(cc, ""))
	localVarQueryParams.Add("mm", parameterToString(mm, ""))
	localVarQueryParams.Add("yy", parameterToString(yy, ""))
	localVarQueryParams.Add("cvv", parameterToString(cvv, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ApiApiService A Void transaction can be used to back out a previous Sale transaction.
A Void transaction can be used to back out a previous Sale transaction.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param transactionId Transaction ID of charged event.
 * @param optional nil or *ApiApiVoidOpts - Optional Parameters:
     * @param "Ticket" (optional.String) -  Ticket Number used by POS
     * @param "Meta" (optional.Interface of interface{}) -  Optional user defined object to be returned with future response
@return []Response
*/

type ApiApiVoidOpts struct {
    Ticket optional.String
    Meta optional.Interface
}

func (a *ApiApiService) Void(ctx context.Context, transactionId string, localVarOptionals *ApiApiVoidOpts) ([]Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/void"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("transactionId", parameterToString(transactionId, ""))
	if localVarOptionals != nil && localVarOptionals.Ticket.IsSet() {
		localVarQueryParams.Add("ticket", parameterToString(localVarOptionals.Ticket.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Meta.IsSet() {
		localVarQueryParams.Add("meta", parameterToString(localVarOptionals.Meta.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
